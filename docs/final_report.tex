\documentclass[10pt, letterpaper]{scrartcl}
\usepackage [english]{babel}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage{color}
\usepackage{tikz}
\usepackage{listings}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{dingbat}
\newcommand{\xmark}{\ding{55}}%
\usetikzlibrary{snakes}
\usetikzlibrary{patterns}
\usepackage[loose]{subfigure}
\usepackage[pdfborder={0 0 0}]{hyperref}


\geometry{margin=2.5cm}

\title{Sasuke - Rootkit Detector Group 4}
\subtitle{TUM \\Chair of IT Security\\  Rootkit Programming WS2014/15}
\author{Martin Herrman \and Gurusiddesha Chandrasekhara}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Introduction}
To detect the rootkits of the other groups we used two different approaches: detection from kernel-space and detection from user-space.
The reason for implenting two different methods was that while detection from within the kernel is much easier than from user-space, not everyone will be able to write, use, or understand LKMs.
This way we can also see which rootkits hide very good (no easy way of detection from user-space) or not so good (easily detected from user-space). 

Our kernel-mode detection program consists of a single kernel module.
Once inserted, it will run multiple tests and write a detection log to a file.
Using this we were able to detect every rootkit in at least one way (most in multiple ways).

Our user-mode detection program, on the other hand, consists of a shell script.
While it is expected to be run with root privileges, it will not try to insert any kernel code to accomplish its task.

Chapter \ref{sec:design} will describe the details of the implementation. Chapter \ref{sec:detection} will give an overview over the different rootkits and describe which tests the failed and which they passed.

\section{Design of Sasuke}\label{sec:design}

\subsection{Loadable Kernel Module}\label{sec:lkm}
There are a few requirements for building the Detection LKM: 
\begin{itemize}
	\item a sane kernel build environment exists
	\item the \emph{System.map} file is present
	\item the kernel version is either 3.16.4 or at least reasonably similar
\end{itemize}
Once these are met, one can just use \texttt{make} inside the source folder to build the module and insert it with \texttt{insmod}. A log of the detection procedure can be found in the file \texttt{/sasuke.log} after the LKM has been successfully inserted.

The following sections will now describe the different approaches used to detect rootkits.

\subsubsection{Detecting manipulation of system calls}
Because the hooking of system calls is something you can expect pretty much every rootkit to do, this was one of the first features to be implemented. There are several ways to accomplish this, many of which our tool will be able to detect.

The simplest way is to overwrite the pointers to different system calls in the system call table.
Detecting this is very easy if you can rely on a valid \emph{System.map} file (for limitations see Chapter \ref{sec:conclusion}).
Our tool simply compares the pointer for a specific system call in the system call table to the pointer which is present in the \emph{System.map} file of this kernel.
If they do not match, a malicious manipulation of the system call table is very likely.
The following code excerpt shows this check for the \texttt{read} system call:

\begin{center}
\lstset{language=C,
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}
#include "sysmap.h"

void **sys_call_table = (void *) sysmap_sys_call_table;

if((void *)sys_call_table[__NR_read] == (void *) sysmap_sys_read) {
	strncpy(message, "read       - OK\n", 64);
	write_to_file(message, strlen(message));
} else {
	hooked_syscalls++;
	strncpy(message, "read       - NOT OK!\n", 64);
	write_to_file(message, strlen(message));
}
\end{lstlisting}
\end{center}

Even though this detection method is very simple, nearly all of the rootkits tested could be detected this way.

But of course "nearly all" is not good enough in the case of security.
For this reason, another group of system call hooking methods is checked for: the direct manipulation of instructions.
An attacker can overwrite the first few instructions of the system call to direct it elsewhere, e.g. his own function.
This can again be detected by a simple comparison if one knows which instructions are supposed to be executed at the beginning of the manipulated system call, as is illustrated by the following example which is again using the \texttt{read} system call:

\lstset{language=C,
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}
#include "sysmap.h"

unsigned int tmp[4] = { 0x00000000, 0x00000000,
		0x00000000, 0x00000000 };
unsigned int original_read[4] = { 0xD5894855, 0xEC834853,
		0x74894848, 0x61E80824 };

if(memcmp(original_read, (void *) sysmap_sys_read,
		sizeof(unsigned int)*4) != 0) {
	
	memcpy(tmp, (void *) sysmap_sys_read, sizeof(unsigned int)*4);
	memset(message, 0, 128);
	sprintf(message, "read            - %08X %08X %08X %08X\n",
		tmp[0], tmp[1], tmp[2], tmp[3]);
	memset(message+127, '\0', 1);
	write_to_file(message, strlen(message));
	hooked_syscalls++;
	
} else {
	
	strncpy(message, "read            - OK\n", 64);
	write_to_file(message, strlen(message));
	
}
\end{lstlisting}

The advantage of using this technique is that it can also be used for other kernel functions which are not referred to in the system call table.
Examples for this are \texttt{packet\_rcv}, \texttt{packet\_rcv\_spkt}, and \texttt{tpacket\_rcv} which are commonly manipulated to hide packets from applications like \texttt{tcpdump}.

A sample output of our LKM for those two features looks like this:

\begin{lstlisting}
[Checking the pointers in the system call table...]
read       - NOT OK!
getdents   - NOT OK!
getdents64 - OK
recvmsg    - NOT OK!
open       - OK
close      - OK
readlink   - OK
readlinkat - OK
kill       - OK
There are 3 manipulated pointers in the system call table.

[Checking the first bytes of some system calls and other important functions...]
read            - OK
getdents        - OK
getdents64      - OK
recvmsg         - OK
open            - OK
close           - OK
readlink        - OK
readlinkat      - OK
kill            - OK
packet_rcv      - 30BDB968 5441C3A0 89485355 EC8348FB
packet_rcv_spkt - 30BF2168 8948C3A0 8A5241FB 8B4C7D47
tpacket_rcv     - 30BE6D68 5441C3A0 89485355 EC8348FB
There are 3 manipulated functions.
\end{lstlisting}

As you can easily see, the pointers to the \texttt{read}, \texttt{getdents}, and \texttt{recvmsg} system calls as well as the instructions of the \texttt{packet\_rcv}, \texttt{packet\_rcv\_spkt}, and \texttt{tpacket\_rcv} functions have been manipulated. In the latter case the instructions present are displayed for further manual analysis.

\subsubsection{Detecting hidden processes}
While a manipulated \texttt{getdents} system call may be indicative of hidden processes (the \texttt{ps} command uses the \emph{proc}-filesystem), there are other ways to further analyse this.

\subsection{Shell script}\label{sec:script}

\section{Detection}\label{sec:detection}

\subsection{Group 1}
\subsection{Group 2}
\subsection{Group 3}
\subsection{Group 4}
\subsection{Group 5}
\subsection{Group 6}
\subsection{Group 7}

\subsection{Comparison of the different rootkits}
\begin{center}
            \begin{tabular}{|l|l|l|l|p{5cm}|}
                Group Number & M1- syscall & M2-processes & M3-Netfilter & M4-modules\\ \hline
                   1 & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline  
                   2 & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline  
                   3 & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline  
                   4 & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline  
                   5 & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline  
                   6 & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline  
                   7 & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline  
            \end{tabular}
\end{center}

\section{Conclusion}\label{sec:conclusion}

\end{document}
